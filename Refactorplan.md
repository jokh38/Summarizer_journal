# 논문 초록 번역 및 리포트 생성 시스템 - 리팩토링 계획서

## 문서 개요

본 문서는 기존 논문 초록 번역 시스템의 리팩토링 계획을 정의합니다. 이 문서는 향후 개발의 단일 참조 자료(Single Source of Truth)로 사용됩니다.

---

## 1. 배경 및 현황 분석

### 1.1 프로젝트 배경

학술 저널의 최신 논문 초록을 자동으로 수집하고 한국어로 번역하여 읽기 쉬운 리포트를 생성하는 자동화 시스템입니다. 주요 목적은 의학물리 분야의 최신 연구 동향을 효율적으로 파악하는 것입니다.

### 1.2 기존 시스템 현황

현재 두 개의 독립적인 스크립트가 존재합니다:
- `journal_summary_html.py`: HTML 형식 리포트 생성
- `journal_summary_md.py`: Markdown 형식 리포트 생성

두 파일은 약 80%의 중복 코드를 가지며, 다음과 같은 기능을 포함합니다:
- RSS 피드를 통한 논문 정보 수집
- 저널 웹사이트에서 초록 추출
- Ollama API를 통한 한국어 번역
- 진행 상태 추적 (중복 처리 방지)
- 로깅 및 오류 처리

### 1.3 식별된 주요 문제점

#### 아키텍처 문제
- **모놀리식 구조**: 모든 기능이 단일 파일에 집중되어 유지보수 어려움
- **코드 중복**: 두 파일 간 80% 이상 중복으로 수정 시 양쪽 모두 변경 필요
- **강한 결합**: 모듈 간 의존성이 명확히 분리되지 않음
- **추상화 부재**: 공통 인터페이스나 기본 클래스 없음

#### 설정 관리 문제
- **하드코딩**: 모델명, URL, 파일 경로가 코드 내 직접 작성됨
- **보안 취약**: API 키나 민감 정보를 코드에 포함할 가능성
- **유연성 부족**: 설정 변경 시 코드 수정 및 재배포 필요

#### 확장성 문제
- **단일 LLM 제공자**: Ollama만 지원하며 다른 LLM으로 전환 어려움
- **출력 형식 확장 어려움**: 새 출력 형식 추가 시 전체 파일 복사 필요
- **저널 추가의 복잡성**: 새 저널 추가 시 코드 수정 필요

#### 운영 문제
- **플랫폼 종속성**: Windows 전용 코드 포함 (파일 열기 명령)
- **오류 복구 부족**: 네트워크 실패, API 타임아웃 등에 대한 재시도 로직 부재
- **진행 상태 관리**: 파일 손상 시 복구 메커니즘 없음
- **로그 관리**: 로그 파일 회전 및 보관 정책 부재

#### 성능 문제
- **순차 처리**: 모든 저널을 순차적으로 처리하여 시간 소요
- **세션 관리 부재**: 각 요청마다 새 HTTP 연결 생성
- **비효율적 컨텍스트 관리**: Ollama 모델의 컨텍스트 초기화 비효율

---

## 2. 리팩토링 목표

### 2.1 핵심 원칙

1. **모듈화 (Modularity)**: 기능별로 명확히 분리된 독립 모듈
2. **확장성 (Extensibility)**: 새로운 LLM, 출력 형식, 저널 추가 용이
3. **유지보수성 (Maintainability)**: 코드 중복 제거 및 명확한 구조
4. **신뢰성 (Reliability)**: 강건한 오류 처리 및 복구 메커니즘
5. **설정 가능성 (Configurability)**: 코드 수정 없이 설정으로 동작 제어
6. **플랫폼 독립성 (Platform Independence)**: 다양한 OS에서 동작

### 2.2 구체적 목표

- 코드 중복률 80% → 0% 감소
- 새 LLM 제공자 추가 시 기존 코드 수정 불필요
- 새 출력 형식 추가 시 독립적인 클래스로 구현
- 설정 파일만으로 전체 시스템 동작 제어
- 네트워크 실패 시 자동 재시도 및 복구
- 크로스 플랫폼 지원 (Windows, Linux, macOS)

---

## 3. 새로운 아키텍처 설계

### 3.1 프로젝트 구조

```
/summarizer_journal
├── main.py                 # 진입점, 전체 흐름 조율
├── config.yaml             # 설정 파일
├── requirements.txt        # Python 패키지 의존성
├── .env.example            # 환경 변수 예제
├── .gitignore              # 버전 관리 제외 파일
├── run_summarizer.sh       # Linux/Mac 실행 스크립트
├── run_summarizer.bat      # Windows 실행 스크립트
├── /src                    # 소스 코드
│   ├── __init__.py
│   ├── config_loader.py    # 설정 관리
│   ├── journal_processor.py # RSS 피드 및 초록 추출
│   ├── translator.py       # 번역기 추상화 및 구현
│   ├── output_generator.py # 출력 형식 생성
│   └── progress_manager.py # 진행 상태 관리
├── /data                   # 데이터 파일
│   ├── journal_list.txt    # 저널 목록
│   └── progress.json       # 진행 상태 (자동 생성)
├── /logs                   # 로그 파일 (자동 생성)
├── /output                 # 생성된 리포트 (자동 생성)
└── /tests                  # 테스트 코드
    ├── __init__.py
    ├── test_translator.py
    ├── test_journal_processor.py
    └── test_output_generator.py
```

### 3.2 모듈별 책임과 설계

#### 3.2.1 config_loader.py - 설정 관리

**책임**:
- `config.yaml` 파일 로드 및 파싱
- 환경 변수 로드 및 병합
- 설정 유효성 검증
- 설정 객체 제공

**설계 원칙**:
- YAML 스키마 검증으로 잘못된 설정 조기 탐지
- 환경 변수를 통한 민감 정보 오버라이드 지원
- 기본값 제공으로 필수 항목 최소화
- 불변 설정 객체 반환으로 런타임 변경 방지

**주요 기능**:
- YAML 파일 파싱
- 환경 변수 치환 (예: `${OLLAMA_API_KEY}`)
- 필수 필드 검증
- 타입 검증 (문자열, 숫자, 불린, 리스트 등)
- 중첩된 설정 접근을 위한 편의 메서드

#### 3.2.2 translator.py - 번역기 추상화

**책임**:
- 다양한 LLM 제공자와의 인터페이스 통일
- 번역 요청 처리 및 응답 정규화
- 오류 처리 및 재시도 로직
- 폴백 메커니즘

**설계 원칙**:
- 추상 기본 클래스(Abstract Base Class) 패턴
- 각 LLM 제공자별 구체 클래스 구현
- 팩토리 패턴을 통한 동적 인스턴스 생성
- 의존성 주입으로 설정 전달

**클래스 계층**:
- `BaseTranslator`: 추상 기본 클래스
  - `translate(title, abstract)`: 추상 메서드
  - `validate_response()`: 응답 검증
  - `retry_on_failure()`: 재시도 로직

- `OllamaTranslator`: Ollama API 구현
  - HTTP 요청 처리
  - 스트리밍 vs 비스트리밍 지원
  - 모델 로드/언로드 관리

- `LlamaCppTranslator`: llama.cpp 로컬 모델 구현
  - 로컬 모델 파일 로드
  - 파라미터 설정 (컨텍스트, 온도 등)

- `OpenAITranslator`: OpenAI API 구현 (향후 확장)
- `AnthropicTranslator`: Anthropic Claude API 구현 (향후 확장)

**오류 처리**:
- 네트워크 타임아웃: 지수 백오프 재시도
- API 오류: 폴백 번역기로 전환
- 응답 검증 실패: 로깅 후 원문 반환

#### 3.2.3 journal_processor.py - 저널 처리

**책임**:
- RSS 피드 파싱
- 저널 웹사이트에서 초록 추출
- 논문 메타데이터 정규화
- 키워드 추출

**설계 원칙**:
- 저널별 추출 전략 패턴
- 설정 기반 선택자 관리
- HTTP 세션 재사용으로 성능 향상
- 강건한 HTML 파싱 및 예외 처리

**주요 기능**:
- RSS 피드 파싱 (`feedparser` 활용)
- 저널별 초록 추출기 매핑
- HTML 태그 제거 및 텍스트 정규화
- 출판일, 제목, 링크 메타데이터 추출
- 의학물리 키워드 사전 기반 키워드 추출
- User-Agent 설정으로 봇 차단 우회
- 요청 간 지연(delay) 설정으로 서버 부하 방지

**추출 전략**:
- 설정 파일에 저널별 CSS 선택자 정의
- 선택자 실패 시 폴백 전략 (여러 선택자 시도)
- 초록 없는 경우 로깅 후 건너뛰기

**확장성**:
- 새 저널 추가 시 설정 파일에 선택자만 추가
- 복잡한 추출 로직이 필요한 경우 커스텀 추출기 클래스 등록

#### 3.2.4 output_generator.py - 출력 생성

**책임**:
- 번역된 논문 정보를 다양한 형식으로 변환
- 파일 생성 및 저장
- 템플릿 기반 렌더링

**설계 원칙**:
- 추상 기본 클래스로 공통 인터페이스 정의
- 형식별 구체 클래스 구현
- 팩토리 패턴으로 동적 생성기 선택
- 출력 파일 명명 규칙 표준화

**클래스 계층**:
- `BaseOutputGenerator`: 추상 기본 클래스
  - `start_file()`: 파일 헤더 작성
  - `add_journal_section()`: 저널 섹션 추가
  - `add_paper()`: 논문 항목 추가
  - `end_file()`: 파일 푸터 작성

- `MarkdownGenerator`: Markdown 형식 구현
  - 접기/펼치기 가능한 섹션 (`<details>`)
  - 체크박스 형식의 논문 목록
  - 키워드 태그 표시

- `HtmlGenerator`: HTML 형식 구현
  - 인터랙티브 접기/펼치기 JavaScript
  - CSS 스타일링
  - 반응형 디자인

- `JsonGenerator`: JSON 형식 구현 (향후 확장)
- `PdfGenerator`: PDF 형식 구현 (향후 확장)

**템플릿 관리**:
- 헤더/푸터 템플릿 분리
- 날짜, 제목 등 동적 값 치환
- 출력 디렉토리 자동 생성

**파일 명명**:
- 형식: `papers_summary_YYYYMMDD.{ext}`
- 중복 시 타임스탬프 추가

#### 3.2.5 progress_manager.py - 진행 상태 관리

**책임**:
- 처리된 논문 추적
- 중복 처리 방지
- 진행 상태 영속화
- 백업 및 복구

**설계 원칙**:
- JSON 기반 영속화
- 원자적 쓰기 작업 (임시 파일 + 이동)
- 백업 파일 자동 생성
- 손상된 파일 감지 및 복구

**데이터 구조**:
```
{
  "journal_name": {
    "last_processed": "ISO 8601 timestamp",
    "processed_ids": ["논문 ID 목록"],
    "last_success": "ISO 8601 timestamp",
    "error_count": 0
  }
}
```

**주요 기능**:
- 논문 ID 기반 중복 확인
- 마지막 처리 시간 추적
- 오류 발생 저널 우선 재처리
- 오래된 항목 자동 정리 (설정 가능한 보존 기간)
- 파일 손상 시 백업에서 복구
- 원자적 업데이트로 동시성 문제 방지

**백업 전략**:
- 변경 전 자동 백업 생성
- 최대 N개 백업 유지 (설정 가능)
- 순환 백업 (오래된 것부터 삭제)

#### 3.2.6 main.py - 진입점 및 조율

**책임**:
- 전체 워크플로우 조율
- 모듈 간 의존성 주입
- 최상위 예외 처리
- 명령줄 인터페이스

**설계 원칙**:
- 의존성 주입 패턴
- 조기 실패 (설정 검증 우선)
- 우아한 종료 및 정리
- 진행 상황 로깅

**실행 흐름**:
1. 명령줄 인자 파싱
2. 설정 로드 및 검증
3. 로거 초기화
4. 의존성 생성 (Translator, OutputGenerator, ProgressManager)
5. 저널 목록 로드
6. 각 저널 처리:
   - RSS 피드 파싱
   - 미처리 논문 필터링
   - 초록 추출
   - 번역 수행
   - 출력 파일에 추가
   - 진행 상태 업데이트
7. 최종 파일 저장
8. 리소스 정리 (모델 언로드 등)

**명령줄 옵션**:
- `--config`: 사용자 정의 설정 파일 경로
- `--format`: 출력 형식 오버라이드 (html, md, json)
- `--journals`: 특정 저널만 처리
- `--force`: 진행 상태 무시하고 전체 재처리
- `--dry-run`: 실제 번역/저장 없이 시뮬레이션

---

## 4. 설정 관리 체계

### 4.1 config.yaml 구조

**설계 철학**:
- 계층적 구조로 관련 설정 그룹화
- 주석을 통한 자세한 설명
- 합리적인 기본값 제공
- 환경별 오버라이드 지원

**주요 섹션**:

#### 일반 설정
- `output_format`: 기본 출력 형식 (html, md, json)
- `output_dir`: 출력 파일 디렉토리
- `log_level`: 로깅 레벨 (DEBUG, INFO, WARNING, ERROR)
- `log_dir`: 로그 파일 디렉토리
- `platform`: 플랫폼별 동작 (auto, windows, linux, macos)

#### 번역기 설정
- `translator.provider`: 사용할 LLM 제공자 (ollama, llama_cpp, openai)
- `translator.timeout`: API 요청 타임아웃 (초)
- `translator.max_retries`: 최대 재시도 횟수
- `translator.retry_delay`: 재시도 간 지연 (초)
- `translator.fallback_provider`: 실패 시 폴백 제공자

**Ollama 전용 설정**:
- `translator.ollama.api_url`: Ollama API 엔드포인트
- `translator.ollama.model`: 모델명
- `translator.ollama.num_ctx`: 컨텍스트 윈도우 크기
- `translator.ollama.temperature`: 온도 파라미터
- `translator.ollama.num_predict`: 최대 생성 토큰 수

**llama.cpp 전용 설정**:
- `translator.llama_cpp.model_path`: 모델 파일 경로
- `translator.llama_cpp.n_gpu_layers`: GPU 레이어 수
- `translator.llama_cpp.n_threads`: CPU 스레드 수

#### 저널 처리 설정
- `journals.list_file`: 저널 목록 파일 경로
- `journals.request_delay`: 요청 간 지연 (초)
- `journals.timeout`: 웹 요청 타임아웃
- `journals.user_agent`: HTTP User-Agent
- `journals.max_papers_per_journal`: 저널당 최대 처리 논문 수

**저널별 추출기 설정**:
- 도메인을 키로 하는 매핑
- CSS 선택자 또는 XPath
- 폴백 선택자 목록

#### 진행 상태 관리 설정
- `progress.file_path`: 진행 상태 파일 경로
- `progress.backup_count`: 유지할 백업 수
- `progress.retention_days`: 처리 기록 보존 기간

#### 키워드 추출 설정
- `keywords.enabled`: 키워드 추출 활성화
- `keywords.max_count`: 최대 키워드 수
- `keywords.custom_terms`: 사용자 정의 용어 목록

### 4.2 환경 변수 관리

**민감 정보 보호**:
- API 키는 환경 변수로만 관리
- `.env` 파일 지원 (개발 환경)
- `.env.example` 제공 (버전 관리 포함)

**환경 변수 목록**:
- `OLLAMA_API_KEY`: Ollama API 키 (필요시)
- `OPENAI_API_KEY`: OpenAI API 키
- `CONFIG_PATH`: 설정 파일 경로 오버라이드
- `LOG_LEVEL`: 로그 레벨 오버라이드

**우선순위**:
1. 명령줄 인자
2. 환경 변수
3. config.yaml
4. 기본값

### 4.3 설정 검증

**검증 항목**:
- 필수 필드 존재 확인
- 타입 검증 (문자열, 정수, 불린 등)
- 범위 검증 (숫자 범위, 유효한 선택지 등)
- 파일 경로 존재 확인
- URL 형식 검증
- 상호 의존성 검증 (특정 제공자 선택 시 필수 설정)

**검증 시점**:
- 프로그램 시작 시 즉시 검증
- 잘못된 설정 발견 시 명확한 오류 메시지와 함께 종료
- 경고 수준 문제는 로그에 기록 후 기본값 사용

---

## 5. 오류 처리 및 복구 전략

### 5.1 오류 분류

#### 복구 가능한 오류
- 네트워크 타임아웃
- 일시적 API 오류 (429, 503)
- 특정 논문의 초록 추출 실패
- 번역 응답 형식 오류

**처리 방법**:
- 지수 백오프 재시도
- 폴백 메커니즘 활용
- 해당 항목 건너뛰고 계속 진행
- 상세한 로그 기록

#### 복구 불가능한 오류
- 설정 파일 오류
- 필수 파일 누락
- 인증 실패
- 디스크 공간 부족

**처리 방법**:
- 명확한 오류 메시지 출력
- 프로그램 종료 전 리소스 정리
- 부분 결과 저장 (가능한 경우)
- 오류 로그 상세 기록

### 5.2 재시도 로직

**지수 백오프 전략**:
- 첫 시도 실패 시 대기 시간: 1초
- 재시도마다 대기 시간 2배 증가
- 최대 대기 시간: 60초
- 최대 재시도 횟수: 설정 가능 (기본 3회)

**재시도 조건**:
- HTTP 상태 코드 429 (Too Many Requests)
- HTTP 상태 코드 503 (Service Unavailable)
- 네트워크 타임아웃
- 연결 오류

**재시도하지 않는 조건**:
- HTTP 상태 코드 401, 403 (인증 오류)
- HTTP 상태 코드 404 (리소스 없음)
- 데이터 형식 오류

### 5.3 로깅 전략

**로그 레벨 사용**:
- **DEBUG**: 상세한 디버깅 정보 (변수 값, 중간 결과)
- **INFO**: 일반 진행 상황 (저널 처리 시작/완료, 논문 개수)
- **WARNING**: 주의 필요 (폴백 사용, 재시도 중)
- **ERROR**: 오류 발생하지만 계속 진행 (특정 논문 처리 실패)
- **CRITICAL**: 치명적 오류 (프로그램 종료 필요)

**로그 출력 대상**:
- 콘솔: INFO 레벨 이상
- 파일: DEBUG 레벨 이상
- 로그 파일 회전: 10MB 단위, 최대 5개 파일 유지

**로그 형식**:
- 타임스탬프 (ISO 8601)
- 로그 레벨
- 모듈명
- 메시지
- 예외 스택 트레이스 (오류 발생 시)

**구조화 로그**:
- JSON 형식 로그 옵션 제공
- 로그 분석 도구와 통합 용이

---

## 6. 성능 최적화 전략

### 6.1 병렬 처리

**저널 레벨 병렬 처리**:
- 각 저널을 독립적으로 처리
- 멀티프로세싱 또는 멀티스레딩 활용
- 동시 처리 워커 수: CPU 코어 수 또는 설정값

**제약 사항**:
- 진행 상태 파일 동시 쓰기 방지 (락 메커니즘)
- API 요청 제한 고려 (전역 레이트 리미터)
- 메모리 사용량 모니터링

**논문 레벨 병렬 처리**:
- 동일 저널 내 여러 논문 동시 번역
- 비동기 I/O 활용 (asyncio)
- 배치 번역 지원 (LLM이 지원하는 경우)

### 6.2 캐싱 전략

**HTTP 세션 재사용**:
- `requests.Session` 객체 재사용
- 연결 풀링으로 성능 향상
- Keep-Alive 연결 유지

**번역 결과 캐싱**:
- 동일 초록 재번역 방지
- 로컬 캐시 (메모리 또는 디스크)
- TTL 설정 (시간 기반 만료)

**RSS 피드 캐싱**:
- ETags 또는 Last-Modified 헤더 활용
- 변경 없으면 재파싱 생략

### 6.3 리소스 관리

**메모리 최적화**:
- 스트리밍 방식으로 대용량 RSS 처리
- 배치 단위 출력 파일 쓰기
- 처리 완료 후 메모리 해제

**디스크 I/O 최적화**:
- 버퍼링된 쓰기
- 임시 파일 활용 후 원자적 이동
- 불필요한 중간 파일 생성 방지

**네트워크 최적화**:
- 연결 타임아웃 적절히 설정
- 압축 전송 활성화 (gzip)
- DNS 캐싱

---

## 7. 테스트 전략

### 7.1 단위 테스트

**테스트 대상 모듈**:
- `config_loader`: 설정 로드, 검증, 환경 변수 치환
- `translator`: 각 번역기 클래스의 번역 로직
- `journal_processor`: RSS 파싱, 초록 추출
- `output_generator`: 각 형식의 출력 생성
- `progress_manager`: 상태 추적, 백업/복구

**테스트 방법**:
- pytest 프레임워크 활용
- Mock 객체로 외부 의존성 격리
- 테스트 픽스처로 재사용 가능한 설정 제공

### 7.2 통합 테스트

**테스트 시나리오**:
- 전체 워크플로우 실행 (설정 로드 → 처리 → 출력)
- 다양한 설정 조합
- 오류 발생 시 복구 메커니즘
- 진행 상태 연속성 (중단 후 재개)

**테스트 데이터**:
- 샘플 RSS 피드 파일
- 샘플 HTML 페이지 (초록 포함)
- Mock LLM 응답

### 7.3 엔드투엔드 테스트

**실제 환경 테스트**:
- 실제 RSS 피드 사용
- 실제 LLM API 호출 (제한적)
- 생성된 출력 파일 검증

**회귀 테스트**:
- 기존 기능이 새 변경으로 인해 손상되지 않음 확인
- CI/CD 파이프라인 통합

---

## 8. 문서화 전략

### 8.1 코드 문서화

**Docstring 규칙**:
- 모든 모듈, 클래스, 함수에 docstring 작성
- Google 스타일 또는 NumPy 스타일 docstring
- 파라미터, 반환값, 예외 명시

**타입 힌트**:
- Python 3.7+ 타입 힌트 활용
- mypy로 정적 타입 검사

### 8.2 사용자 문서

**README.md**:
- 프로젝트 개요
- 주요 기능
- 빠른 시작 가이드
- 라이선스 정보

**INSTALL.md**:
- 시스템 요구사항
- 의존성 설치
- 설정 파일 작성
- 환경 변수 설정
- 검증 방법

**USER_GUIDE.md**:
- 상세 사용 방법
- 설정 옵션 설명
- 명령줄 인터페이스
- 트러블슈팅

**API_REFERENCE.md**:
- 각 모듈의 API 문서
- 클래스 및 메서드 설명
- 사용 예제

### 8.3 개발자 문서

**CONTRIBUTING.md**:
- 기여 가이드라인
- 코드 스타일 규칙
- 커밋 메시지 규칙
- PR 프로세스

**ARCHITECTURE.md**:
- 시스템 아키텍처 다이어그램
- 모듈 간 의존성
- 데이터 흐름
- 설계 결정 기록

---

## 9. 배포 및 운영

### 9.1 패키징

**배포 형식**:
- PyPI 패키지 (pip 설치 가능)
- Docker 이미지
- 독립 실행 파일 (PyInstaller)

**버전 관리**:
- Semantic Versioning (MAJOR.MINOR.PATCH)
- CHANGELOG.md 유지
- Git 태그 활용

### 9.2 크론 작업 설정

**Linux/macOS (cron)**:
- 실행 스크립트 (`run_summarizer.sh`) 제공
- 가상 환경 활성화
- 로그 리다이렉션
- 오류 알림 (이메일 등)

**샘플 crontab 항목**:
```
# 매주 일요일 오전 9시 실행
0 9 * * 0 /path/to/run_summarizer.sh >> /path/to/logs/cron.log 2>&1
```

**Windows (Task Scheduler)**:
- 배치 스크립트 (`run_summarizer.bat`) 제공
- 작업 스케줄러 XML 템플릿 제공
- 실행 권한 설정 가이드

### 9.3 모니터링

**헬스 체크**:
- 프로그램 정상 완료 시 상태 파일 생성
- 실패 시 오류 플래그 설정
- 외부 모니터링 도구 연동 가능

**알림 메커니즘**:
- 이메일 알림 (오류 발생 시)
- Slack/Discord 웹훅 지원
- 로그 파일 기반 알림

**성능 메트릭**:
- 처리 시간 기록
- 성공/실패 논문 수
- API 호출 횟수 및 비용

---

## 10. 보안 고려사항

### 10.1 민감 정보 보호

**API 키 관리**:
- 환경 변수 또는 키 관리 시스템 사용
- 코드 또는 설정 파일에 하드코딩 금지
- `.gitignore`에 `.env` 파일 추가

**출력 파일 보안**:
- 민감 정보 포함 가능성 검토
- 접근 권한 제한
- 공개 디렉토리에 저장 금지

### 10.2 입력 검증

**RSS 피드 검증**:
- XML 파싱 시 XXE 공격 방지
- 신뢰할 수 없는 소스 제한
- 피드 크기 제한

**HTML 파싱 보안**:
- BeautifulSoup의 안전한 파서 사용
- 스크립트 삽입 방지
- 출력 시 이스케이핑

### 10.3 네트워크 보안

**HTTPS 강제**:
- HTTP URL을 HTTPS로 업그레이드
- 인증서 검증 활성화
- TLS 버전 확인

**요청 제한**:
- User-Agent 설정으로 투명성 확보
- Rate limiting 준수
- robots.txt 존중

---

## 11. 플랫폼 호환성

### 11.1 크로스 플랫폼 지원

**파일 경로 처리**:
- `os.path` 대신 `pathlib.Path` 사용
- 경로 구분자 자동 처리
- 홈 디렉토리 확장 (`~` 지원)

**파일 열기**:
- 플랫폼별 기본 애플리케이션 사용
- `webbrowser` 모듈 활용 (HTML)
- 설정으로 비활성화 가능

**스크립트 실행**:
- Linux/macOS: Bash 스크립트
- Windows: 배치 파일 또는 PowerShell

### 11.2 의존성 관리

**최소 Python 버전**:
- Python 3.8 이상 요구
- 타입 힌트 및 최신 기능 활용

**외부 라이브러리**:
- `feedparser`: RSS 파싱
- `requests`: HTTP 요청
- `beautifulsoup4`: HTML 파싱
- `PyYAML`: YAML 파싱
- `python-dotenv`: 환경 변수 로드
- `pytest`: 테스트 (개발 의존성)

**선택적 의존성**:
- `llama-cpp-python`: llama.cpp 사용 시
- `openai`: OpenAI API 사용 시

---

## 12. 마이그레이션 계획

### 12.1 기존 데이터 호환성

**진행 상태 파일**:
- 기존 `paper_progress.json` 형식 유지
- 필요 시 자동 마이그레이션 스크립트 제공
- 백업 후 변환

**저널 목록 파일**:
- 기존 `journal_list.txt` 형식 호환
- 새 설정 형식으로 마이그레이션 도구 제공

### 12.2 단계적 전환

**Phase 1: 기반 구조**
- 모듈화된 구조 구축
- config.yaml 및 config_loader 구현
- 기존 기능 모듈로 분리

**Phase 2: 추상화 계층**
- Translator 추상화 및 Ollama 구현
- OutputGenerator 추상화 및 HTML/MD 구현
- ProgressManager 분리

**Phase 3: 확장 기능**
- 추가 LLM 제공자 구현
- 오류 처리 강화
- 병렬 처리 추가

**Phase 4: 테스트 및 문서화**
- 단위 테스트 작성
- 통합 테스트 작성
- 사용자 문서 완성

**Phase 5: 배포 및 운영**
- 크론 스크립트 작성
- Docker 이미지 생성
- 모니터링 설정

---

## 13. 확장 가능성

### 13.1 향후 기능

**번역 품질 향상**:
- 번역 후 후처리 (맞춤법 검사)
- 여러 번역 비교 및 최적 선택
- 전문 용어 사전 통합

**지능형 필터링**:
- 관심 주제 기반 논문 필터링
- 중요도 점수 계산
- 개인화된 추천

**협업 기능**:
- 다중 사용자 지원
- 공유 진행 상태
- 댓글 및 주석 기능

**분석 기능**:
- 트렌드 분석 (시간별 주제 변화)
- 키워드 통계
- 저널별 활동 대시보드

### 13.2 통합 가능성

**외부 시스템 연동**:
- Reference manager (Zotero, Mendeley)
- 노트 앱 (Notion, Obsidian)
- 이메일 자동 발송
- 클라우드 스토리지 (Google Drive, Dropbox)

**API 제공**:
- RESTful API 서버 모드
- 웹 인터페이스
- 모바일 앱 연동

---

## 14. 성공 기준

### 14.1 기술적 지표

- [ ] 코드 중복률 < 5%
- [ ] 테스트 커버리지 > 80%
- [ ] 모든 모듈 독립적으로 테스트 가능
- [ ] 새 LLM 제공자 추가 시 기존 코드 수정 불필요
- [ ] 새 출력 형식 추가 < 100 줄 코드
- [ ] 설정 변경만으로 모든 주요 기능 제어 가능

### 14.2 운영 지표

- [ ] 네트워크 오류 시 자동 복구율 > 95%
- [ ] 평균 처리 시간 < 기존 시스템 150%
- [ ] 로그를 통한 문제 진단 가능
- [ ] 6개월간 설정 파일 변경 없이 안정적 동작

### 14.3 유지보수 지표

- [ ] 새 개발자가 1일 내 개발 환경 설정 가능
- [ ] 버그 수정 시 영향 범위를 단일 모듈로 한정 가능
- [ ] 모든 공개 API에 문서화 존재
- [ ] 주요 워크플로우에 대한 다이어그램 존재

---

## 15. 리스크 관리

### 15.1 식별된 리스크

**기술적 리스크**:
- LLM API 변경으로 인한 호환성 문제
- 저널 웹사이트 구조 변경으로 초록 추출 실패
- 의존성 라이브러리의 Breaking Change

**완화 전략**:
- API 버전 고정 및 변경 모니터링
- 저널별 다중 추출 전략 및 폴백
- 의존성 버전 범위 신중히 설정

**운영 리스크**:
- 크론 작업 실패 알림 누락
- 디스크 공간 부족
- API 비용 초과

**완화 전략**:
- 모니터링 및 알림 시스템 구축
- 오래된 파일 자동 정리
- API 호출 수 제한 및 모니터링

### 15.2 롤백 계획

**설정 변경 롤백**:
- 설정 파일 버전 관리
- 이전 설정으로 즉시 복구 가능

**코드 배포 롤백**:
- Git 태그 활용
- 이전 버전으로 즉시 전환 가능
- 진행 상태 파일 호환성 유지

---

## 16. 타임라인 및 마일스톤

### Phase 1: 기반 구조 (1-2주)
- 프로젝트 구조 설정
- config.yaml 설계 및 config_loader 구현
- 기존 코드를 모듈로 분리
- 기본 로깅 설정

### Phase 2: 추상화 계층 (2-3주)
- Translator 추상 클래스 및 Ollama 구현
- OutputGenerator 추상 클래스 및 HTML/MD 구현
- ProgressManager 독립 모듈화
- JournalProcessor 분리

### Phase 3: 통합 및 개선 (1-2주)
- main.py 구현
- 의존성 주입 설정
- 오류 처리 강화
- 재시도 로직 구현

### Phase 4: 확장 기능 (2-3주)
- llama.cpp Translator 구현
- 병렬 처리 추가
- 성능 최적화
- 추가 출력 형식 (선택적)

### Phase 5: 테스트 (1-2주)
- 단위 테스트 작성
- 통합 테스트 작성
- 엔드투엔드 테스트
- 버그 수정

### Phase 6: 문서화 및 배포 (1주)
- 사용자 문서 작성
- 설치 가이드 작성
- 크론 스크립트 작성
- Docker 이미지 생성

**총 예상 기간**: 8-13주

---

## 17. 결론

본 리팩토링 계획은 기존 시스템의 문제점을 체계적으로 해결하고, 확장 가능하고 유지보수하기 쉬운 아키텍처를 구축하는 것을 목표로 합니다. 모듈화, 추상화, 설정 기반 관리를 통해 코드 품질을 크게 향상시키고, 향후 요구사항 변화에 유연하게 대응할 수 있는 시스템을 만들 것입니다.

이 문서는 개발의 단일 참조 자료로 활용되며, 구현 과정에서 발견되는 새로운 요구사항이나 개선점은 지속적으로 반영될 것입니다.
